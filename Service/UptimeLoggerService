#!/bin/bash
DEBUG=false
UPDATE=false
if [[ "$*" == *"--debug"* ]]; then
    DEBUG=true
    if [[ "$*" == *"--exit-with-update"* ]]; then
        UPDATE=true
    fi
fi
VERSION=5
activetime=0

# Check for version option
if [[ "$*" == *"-v"* ]] || [[ "$*" == *"--version"* ]]; then
    echo "$VERSION"
    exit 0
fi

# Define paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

if [ $DEBUG = true ]; then
    LOGS_DIR="$SCRIPT_DIR/logs"
else
    LOGS_DIR="/Library/Application Support/UptimeLogger"
fi
INDEXED_LOGS_DIR="$LOGS_DIR/indexed"

ACTIVE_FILE="$LOGS_DIR/activetime"
LOG_LATEST="$LOGS_DIR/latest"
INTERVAL_FILE="$LOGS_DIR/config"
SUSPENDED_FILE="$LOGS_DIR/suspended"
if [[ ! -d "$LOGS_DIR" ]]; then
    mkdir "$LOGS_DIR"
fi
if [[ ! -d "$INDEXED_LOGS_DIR" ]]; then
    mkdir "$INDEXED_LOGS_DIR"
fi
chmod -R 777 "$LOGS_DIR"
chmod 777 "$LOGS_DIR"
rm "$SUSPENDED_FILE"

# Allowed Shutdown Features
UPDATE_FILE="$LOGS_DIR/updated"

function allowShutdown() {
    echo "shutdown allowed" >>"$LOG_LATEST"
    rm "$SUSPENDED_FILE"
    rm "$ACTIVE_FILE"
    rm "$LOG_LATEST"
}

# Registra a data e hora de inicialização
if [ -f "$UPDATE_FILE" ]; then
    ADDEDLOG="$(grep suspended "$LOG_LATEST")"
    STARTUP="$(cat "$UPDATE_FILE")"
    activetime=$(cat "$ACTIVE_FILE")
    rm "$UPDATE_FILE"
else
    ADDEDLOG=""
    STARTUP="$(date +"%Y-%m-%d_%H-%M-%S")"
fi

# Set log files names
function setFiles() {
    LOG_FILE="$LOGS_DIR/log_$STARTUP.txt"
    PLOG_FILE="$LOGS_DIR/log_$STARTUP.log"
    if [ ! -f "$LOG_FILE" ]; then
        echo "version: $VERSION"$'\n' >"$LOG_FILE"
    fi
    ln -sf "$LOG_FILE" "$LOG_LATEST"
    echo "#### INIT FILE $LOG_FILE #####"

    if [ $DEBUG = true ]; then
        echo ""
        echo "OSTYPE: $OSTYPE"
        echo "SCRIPT_DIR: $SCRIPT_DIR"
        echo "LOGS_DIR: $LOGS_DIR"
        echo "LOG_LATEST: $LOG_LATEST"
        echo "LOG_FILE: $LOG_FILE"
        echo "PLOG_FILE: $PLOG_FILE"
        echo "STARTUP: $STARTUP"
        echo ""
    fi
}
setFiles

function finishwithUpdate() {
    echo "$STARTUP" >"$UPDATE_FILE"
    echo "allowing update on exit"
}

cleanup() {
    kill $(jobs -p) 2>/dev/null
    if [ $UPDATE = true ]; then
        finishwithUpdate
    else
        allowShutdown
    fi
    # Encerrar os processos em segundo plano
    exit 0
}
trap cleanup SIGINT SIGTERM

# LOG V5
# version: [0-9]+
# ended: %Y-%m-%d_%H-%M-%S
# sysversion: String
# batery: [0-9]+%
# charging: true/false
# boottime: [0-9]+ (timestamp)
# activetime: [0-9]+ (seconds interval)
# uptime: [0-9]+ (seconds interval)
# logprocessinterval: [0-9]+
# suspended: [0-9]+ %Y-%m-%d_%H-%M-%S (miltiple lines)

lasttimestep=$(date +%s)
while true; do
    now=$(date +%s)
    diff=$((now - lasttimestep))

    if [ $diff -gt 0 ] && [ $diff -le 5 ]; then
        activetime=$((activetime + diff))
        lasttimestep=$now
    elif [ $diff -gt 5 ]; then
        echo -n "$diff" > "$SUSPENDED_FILE"
        lasttimestep=$now
    fi
    echo -n "$activetime" >"$ACTIVE_FILE"
    sleep 0.2
done &

# Loop infinito para atualizar o uptime a cada 1 segundo
COUNT=0
while true; do
    if [ -f "$SUSPENDED_FILE" ]; then
        ADDEDLOG+="suspended: $(cat "$SUSPENDED_FILE") $(date +"%Y-%m-%d_%H-%M-%S")"$'\n'
        echo "$LOG"
        echo "$LOG" > "$LOG_FILE"
        rm "$SUSPENDED_FILE"
    fi
    LOG="version: $VERSION"$'\n'
    LOG+="ended: $(date +"%Y-%m-%d_%H-%M-%S")"$'\n'
    LOG+="activetime: $(cat "$ACTIVE_FILE")"$'\n'

    # Verifica o tipo de sistema operacional
    if [[ "$OSTYPE" == "darwin"* ]]; then
        boottimestamp=$(sysctl -n kern.boottime | awk -F'[, ]' '{print $4}')
        currenttimestamp=$(date +%s)
        elapsedtime=$((currenttimestamp - boottimestamp))
        battery=$(pmset -g batt)

        LOG+="sysversion: $(sw_vers -productVersion)"$'\n'
        LOG+="batery: $(echo "$battery" | grep -Eo '[0-9]+%')"$'\n'
        if echo "$battery" | grep -q "discharging"; then
            LOG+="charging: false"$'\n'
        else
            LOG+="charging: true"$'\n'
        fi

        LOG+="boottime: $boottimestamp"$'\n'
        LOG+="uptime: $elapsedtime"$'\n'
    else
        # Define o comando para obter o tempo de inicialização no Linux
        UPTIME=$(uptime -p)

        LOG+="lastrecord: $UPTIME"$'\n'
    fi

    if [ -r "$INTERVAL_FILE" ]; then
        EACHSEC=$(cat "$INTERVAL_FILE")
        if [ $((COUNT % EACHSEC)) -eq 0 ]; then
            ps -ax -o user,pid,pcpu,pmem,start,time,command >"$PLOG_FILE"
            if [ $DEBUG = true ]; then
                echo "logged proceess to file"
            fi
        fi
        LOG+="logprocessinterval: $EACHSEC"$'\n'
    fi

    LOG+="$ADDEDLOG"
    echo "$LOG" > "$LOG_FILE"

    if [ $DEBUG = true ]; then
        echo "$LOG"
    fi

    sleep 1
    ((COUNT++))
done
